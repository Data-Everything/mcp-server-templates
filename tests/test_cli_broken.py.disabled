"""
Comprehensive tests for the CLI interface.

Tests all CLI commands, argument parsing, error handling,
and output formatting with comprehensive coverage.
"""

import json
import tempfile
from pathlib import Path
from unittest.mock import MagicMock, Mock, patch

import pytest
from click.testing import CliRunner

from mcp_template import MCPDeployer, main


class TestCLICore:
    """Test core CLI functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    def test_cli_help(self):
        """Test CLI help output."""
        result = self.runner.invoke(cli, ["--help"])

        assert result.exit_code == 0
        assert "Usage:" in result.output
        assert "deploy" in result.output
        assert "list" in result.output
        assert "create" in result.output

    def test_cli_version(self):
        """Test CLI version output."""
        result = self.runner.invoke(cli, ["--version"])

        assert result.exit_code == 0
        # Should contain version information

    def test_cli_no_args(self):
        """Test CLI with no arguments."""
        result = self.runner.invoke(cli, [])

        # Should show help or error
        assert result.exit_code in [0, 2]


class TestDeployCommand:
    """Test deploy command functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.DeploymentManager")
    def test_deploy_basic(self, mock_manager_class):
        """Test basic deployment command."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "demo-test",
            "status": "deployed",
            "container_id": "test123",
        }

        result = self.runner.invoke(deploy, ["demo"])

        assert result.exit_code == 0
        mock_manager.deploy_template.assert_called_once()

    @patch("mcp_template.DeploymentManager")
    def test_deploy_with_backend(self, mock_manager_class):
        """Test deployment with specific backend."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "demo-test",
            "status": "deployed",
        }

        result = self.runner.invoke(deploy, ["demo", "--backend", "mock"])

        assert result.exit_code == 0
        args, kwargs = mock_manager.deploy_template.call_args
        assert kwargs.get("backend") == "mock"

    @patch("mcp_template.DeploymentManager")
    def test_deploy_with_config_file(self, mock_manager_class):
        """Test deployment with configuration file."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "demo-test",
            "status": "deployed",
        }

        # Create temporary config file
        config_data = {"hello_from": "Config File", "log_level": "debug"}

        with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as f:
            json.dump(config_data, f)
            config_file = f.name

        try:
            result = self.runner.invoke(deploy, ["demo", "--config-file", config_file])

            assert result.exit_code == 0
            mock_manager.deploy_template.assert_called_once()
        finally:
            Path(config_file).unlink()

    @patch("mcp_template.DeploymentManager")
    def test_deploy_with_no_pull(self, mock_manager_class):
        """Test deployment with --no-pull flag."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "demo-test",
            "status": "deployed",
        }

        result = self.runner.invoke(deploy, ["demo", "--no-pull"])

        assert result.exit_code == 0
        args, kwargs = mock_manager.deploy_template.call_args
        assert kwargs.get("pull_image") is False

    @patch("mcp_template.DeploymentManager")
    def test_deploy_with_custom_name(self, mock_manager_class):
        """Test deployment with custom name."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "custom-name",
            "status": "deployed",
        }

        result = self.runner.invoke(deploy, ["demo", "--name", "custom-name"])

        assert result.exit_code == 0
        args, kwargs = mock_manager.deploy_template.call_args
        assert kwargs.get("deployment_name") == "custom-name"

    @patch("mcp_template.DeploymentManager")
    def test_deploy_template_not_found(self, mock_manager_class):
        """Test deployment with non-existent template."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.side_effect = ValueError("Template not found")

        result = self.runner.invoke(deploy, ["non-existent"])

        assert result.exit_code != 0
        assert "Template not found" in result.output

    @patch("mcp_template.DeploymentManager")
    def test_deploy_invalid_backend(self, mock_manager_class):
        """Test deployment with invalid backend."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.side_effect = ValueError("Unsupported backend")

        result = self.runner.invoke(deploy, ["demo", "--backend", "invalid"])

        assert result.exit_code != 0
        assert "Unsupported backend" in result.output


class TestListCommand:
    """Test list command functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.DeploymentManager")
    def test_list_deployments(self, mock_manager_class):
        """Test listing deployments."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.list_deployments.return_value = [
            {
                "name": "demo-deployment",
                "template": "demo",
                "status": "running",
                "created": "2024-01-01T00:00:00Z",
            },
            {
                "name": "test-deployment",
                "template": "test",
                "status": "stopped",
                "created": "2024-01-01T01:00:00Z",
            },
        ]

        result = self.runner.invoke(list_cmd, [])

        assert result.exit_code == 0
        assert "demo-deployment" in result.output
        assert "test-deployment" in result.output
        assert "running" in result.output

    @patch("mcp_template.DeploymentManager")
    def test_list_with_backend(self, mock_manager_class):
        """Test listing with specific backend."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.list_deployments.return_value = []

        result = self.runner.invoke(list_cmd, ["--backend", "k8s"])

        assert result.exit_code == 0
        mock_manager.list_deployments.assert_called_once_with("k8s")

    @patch("mcp_template.DeploymentManager")
    def test_list_empty(self, mock_manager_class):
        """Test listing when no deployments exist."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.list_deployments.return_value = []

        result = self.runner.invoke(list_cmd, [])

        assert result.exit_code == 0
        assert (
            "No deployments found" in result.output or "empty" in result.output.lower()
        )


class TestCreateCommand:
    """Test create command functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.create_template.TemplateCreator")
    def test_create_basic(self, mock_creator_class):
        """Test basic template creation."""
        mock_creator = Mock()
        mock_creator_class.return_value = mock_creator

        result = self.runner.invoke(create, ["test-template"])

        assert result.exit_code == 0
        mock_creator.create_template.assert_called_once()

    @patch("mcp_template.create_template.create_template_interactive")
    def test_create_interactive(self, mock_interactive):
        """Test interactive template creation."""
        result = self.runner.invoke(create, [])

        # Should trigger interactive mode
        mock_interactive.assert_called_once()

    @patch("mcp_template.create_template.TemplateCreator")
    def test_create_with_config_file(self, mock_creator_class):
        """Test template creation with config file."""
        mock_creator = Mock()
        mock_creator_class.return_value = mock_creator

        config_data = {
            "id": "test-template",
            "name": "Test Template",
            "description": "A test template",
            "version": "1.0.0",
            "author": "Test Author",
        }

        with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as f:
            json.dump(config_data, f)
            config_file = f.name

        try:
            result = self.runner.invoke(create, ["--config-file", config_file])

            assert result.exit_code == 0
            mock_creator_class.assert_called_once()
        finally:
            Path(config_file).unlink()

    def test_create_invalid_config_file(self):
        """Test template creation with invalid config file."""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as f:
            f.write("invalid json")
            config_file = f.name

        try:
            result = self.runner.invoke(create, ["--config-file", config_file])

            assert result.exit_code != 0
            assert "Invalid JSON" in result.output or "error" in result.output.lower()
        finally:
            Path(config_file).unlink()


class TestDeleteCommand:
    """Test delete command functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.DeploymentManager")
    def test_delete_deployment(self, mock_manager_class):
        """Test deleting a deployment."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.delete_deployment.return_value = True

        result = self.runner.invoke(delete, ["test-deployment"])

        assert result.exit_code == 0
        mock_manager.delete_deployment.assert_called_once_with(
            "test-deployment", "docker"
        )

    @patch("mcp_template.DeploymentManager")
    def test_delete_with_backend(self, mock_manager_class):
        """Test deleting with specific backend."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.delete_deployment.return_value = True

        result = self.runner.invoke(delete, ["test-deployment", "--backend", "k8s"])

        assert result.exit_code == 0
        mock_manager.delete_deployment.assert_called_once_with("test-deployment", "k8s")

    @patch("mcp_template.DeploymentManager")
    def test_delete_not_found(self, mock_manager_class):
        """Test deleting non-existent deployment."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.delete_deployment.return_value = False

        result = self.runner.invoke(delete, ["non-existent"])

        assert result.exit_code != 0
        assert "not found" in result.output.lower() or "failed" in result.output.lower()


class TestStatusCommand:
    """Test status command functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.DeploymentManager")
    def test_status_deployment(self, mock_manager_class):
        """Test getting deployment status."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.get_deployment_status.return_value = {
            "name": "test-deployment",
            "status": "running",
            "template": "demo",
            "health": "healthy",
            "created": "2024-01-01T00:00:00Z",
        }

        result = self.runner.invoke(status, ["test-deployment"])

        assert result.exit_code == 0
        assert "test-deployment" in result.output
        assert "running" in result.output
        mock_manager.get_deployment_status.assert_called_once_with(
            "test-deployment", "docker"
        )

    @patch("mcp_template.DeploymentManager")
    def test_status_with_backend(self, mock_manager_class):
        """Test status with specific backend."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.get_deployment_status.return_value = {
            "name": "test-deployment",
            "status": "running",
        }

        result = self.runner.invoke(status, ["test-deployment", "--backend", "mock"])

        assert result.exit_code == 0
        mock_manager.get_deployment_status.assert_called_once_with(
            "test-deployment", "mock"
        )

    @patch("mcp_template.DeploymentManager")
    def test_status_not_found(self, mock_manager_class):
        """Test status for non-existent deployment."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.get_deployment_status.side_effect = ValueError(
            "Deployment not found"
        )

        result = self.runner.invoke(status, ["non-existent"])

        assert result.exit_code != 0
        assert "not found" in result.output.lower()


class TestCLIErrorHandling:
    """Test CLI error handling and edge cases."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    def test_invalid_command(self):
        """Test invalid command."""
        result = self.runner.invoke(cli, ["invalid-command"])

        assert result.exit_code == 2
        assert "No such command" in result.output

    @patch("mcp_template.DeploymentManager")
    def test_deployment_manager_exception(self, mock_manager_class):
        """Test handling of DeploymentManager exceptions."""
        mock_manager_class.side_effect = Exception("Manager initialization failed")

        result = self.runner.invoke(deploy, ["demo"])

        assert result.exit_code != 0

    def test_missing_required_args(self):
        """Test commands with missing required arguments."""
        result = self.runner.invoke(delete, [])

        assert result.exit_code == 2
        assert "Missing argument" in result.output or "Usage:" in result.output

    def test_invalid_backend_option(self):
        """Test invalid backend option."""
        result = self.runner.invoke(deploy, ["demo", "--backend", "invalid"])

        # Should either fail validation or be caught by the deployment manager
        assert result.exit_code != 0 or "Unsupported backend" in result.output


class TestCLIOutput:
    """Test CLI output formatting and verbosity."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.DeploymentManager")
    def test_verbose_output(self, mock_manager_class):
        """Test verbose output mode."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "demo-test",
            "status": "deployed",
            "container_id": "test123",
        }

        result = self.runner.invoke(deploy, ["demo", "--verbose"])

        assert result.exit_code == 0
        # Verbose mode should provide more detailed output

    @patch("mcp_template.DeploymentManager")
    def test_quiet_output(self, mock_manager_class):
        """Test quiet output mode."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.deploy_template.return_value = {
            "deployment_name": "demo-test",
            "status": "deployed",
        }

        result = self.runner.invoke(deploy, ["demo", "--quiet"])

        assert result.exit_code == 0
        # Quiet mode should have minimal output

    @patch("mcp_template.DeploymentManager")
    def test_json_output(self, mock_manager_class):
        """Test JSON output format."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager
        mock_manager.list_deployments.return_value = [
            {"name": "test", "status": "running"}
        ]

        result = self.runner.invoke(list_cmd, ["--format", "json"])

        if result.exit_code == 0:
            # Should be valid JSON
            try:
                json.loads(result.output)
            except json.JSONDecodeError:
                pytest.fail("Output is not valid JSON")


class TestCLIIntegration:
    """Integration tests for CLI functionality."""

    def setup_method(self):
        """Setup for each test method."""
        self.runner = CliRunner()

    @patch("mcp_template.DeploymentManager")
    def test_full_deployment_workflow(self, mock_manager_class):
        """Test complete deployment workflow."""
        mock_manager = Mock()
        mock_manager_class.return_value = mock_manager

        # Deploy
        mock_manager.deploy_template.return_value = {
            "deployment_name": "workflow-test",
            "status": "deployed",
        }

        deploy_result = self.runner.invoke(deploy, ["demo", "--name", "workflow-test"])
        assert deploy_result.exit_code == 0

        # List
        mock_manager.list_deployments.return_value = [
            {"name": "workflow-test", "status": "running", "template": "demo"}
        ]

        list_result = self.runner.invoke(list_cmd, [])
        assert list_result.exit_code == 0
        assert "workflow-test" in list_result.output

        # Status
        mock_manager.get_deployment_status.return_value = {
            "name": "workflow-test",
            "status": "running",
            "template": "demo",
        }

        status_result = self.runner.invoke(status, ["workflow-test"])
        assert status_result.exit_code == 0

        # Delete
        mock_manager.delete_deployment.return_value = True

        delete_result = self.runner.invoke(delete, ["workflow-test"])
        assert delete_result.exit_code == 0
